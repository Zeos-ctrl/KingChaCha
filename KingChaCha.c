/*
 * KingChaCha
 * Author: Connor Bryan
 *
 * This is a simple block cipher based of the Fiestel network.
 * It uses a 64-bit block size and a 128-bit key size.
 *
 * Functions:
 * - SubKey Generation
 * - Initial Permutation
 * - Round Function
 * - Swap Sides
 * - Final Permutation
 */

#include <stdio.h>
#include <stdint.h>
#include <openssl/bio.h>

/**
 * Given a 128-bit key, this function will generate 16 64-bit subkeys.
 * The subkeys are stored in the subKeys array.
 * @param[in] key: 128-bit key
 * @return[out] subKeys: 16 64-bit subkeys
 */
void SubKeyGeneration(uint8_t key[16], uint8_t subKeys[16][8]);

/**
 * Given a 64-bit block, this function will perform the initial permutation.
 * @param[in] block: 64-bit block
 * @return[out] block: 64-bit block after initial permutation
 */
void InitialPermutation(uint8_t block[8]);

/**
 * Given a 64-bit block and a 64-bit subkey, this function will perform the round function.
 * @param[in] block: 64-bit block
 * @param[in] subKey: 64-bit subkey
 */
void RoundFunction(uint8_t block[8], uint8_t subKey[8]);

/**
 * Given a 64-bit block, this function will swap the left and right sides.
 * @param[in] block: 64-bit block
 * @return[out] block: 64-bit block with left and right sides swapped
 */
void CrissCross(uint8_t block[8]);

/**
 * Given a 64-bit block, this function will perform the final permutation.
 * @param[in] block: 64-bit block
 * @return[out] block: 64-bit block after final permutation
 */
void FinalPermutation(uint8_t block[8]);

/**
 * Given a 64-bit block and a 128-bit key, this function will encrypt the block.
 * @param[in] block: 64-bit block
 * @param[in] key: 128-bit key
 */
void Encrypt(uint8_t block[8], uint8_t key[16]);

/**
 * Given a 64-bit block and a 128-bit key, this function will decrypt the block.
 * @param[in] block: 64-bit block
 * @param[in] key: 128-bit key
 */
void Decrypt(uint8_t block[8], uint8_t key[16]);

/**
 * Given a 64-bit block, this function will rotate the block left by 1 bit.
 * @param[in] x: 64-bit block
 */
void RotateKeyLeft(uint8_t x[16]);

/**
 * Given a 64-bit block, this function will rotate the block right by 1 bit.
 * @param[in] x: 64-bit block
 */
void RotateKeyRight(uint8_t x[16]);

void Sbox(uint8_t x[4]);

void SubKeyGeneration(uint8_t key[16], uint8_t subKeys[16][8]) {

    /**
     * The subkeys are generated by splitting the 128-bit key into 16 64-bit subkeys.
     * The algorithm is as follows:
     * 1. The key is deplicated into the left and right sides where the right side 
     * is the reverse of the left side.
     * 2. The left is shifted left by 1 bit and the right is shifted right by 1 bit.
     * 3. The left and right are XORed together to create the subkey.
     */

    uint8_t left[16];
    uint8_t right[16];
    for (int i = 0; i < 16; i++) {
        left[i] = key[i];
        right[i] = key[16 - i];
    }

    uint8_t temp[8];
    for (int i = 0; i < 16; i++) {
        RotateKeyLeft(left); // Shimmy shimmy yay, shimmy yay, shimmy ya
        RotateKeyRight(right); // Drink, swalla-la-la, drink, swalla-la-la
        temp[0] = left[0] ^ right[0];
        temp[1] = left[1] ^ right[1];
        temp[2] = left[2] ^ right[2];
        temp[3] = left[3] ^ right[3];
        temp[4] = left[4] ^ right[4];
        temp[5] = left[5] ^ right[5];
        temp[6] = left[6] ^ right[6];
        temp[7] = left[7] ^ right[7];

        for (int j = 0; j < 8; j++) {
            subKeys[i][j] = temp[j];
        }
    }
}

void RotateKeyLeft(uint8_t x[16]) {
    uint8_t carry = 0;

    for (int i = 0; i < 16; i++) {
        uint8_t temp = x[i];
        x[i] = (x[i] << 1) | carry;  // Left shift with carry
        carry = temp >> 7;  // Extract the MSB as the new carry
    }
}

void RotateKeyRight(uint8_t x[16]) {
    uint8_t carry = 0;

    for (int i = 15; i >= 0; i--) {
        uint8_t temp = x[i];
        x[i] = (x[i] >> 1) | carry;  // Right shift with carry
        carry = temp << 7;  // Extract the LSB as the new carry
    }
}

void CrissCross(uint8_t block[8]) {
    // Defo a better way to do this
    uint8_t temp[8];
    temp[0] = block[4];
    temp[1] = block[5];
    temp[2] = block[6];
    temp[3] = block[7];
    temp[4] = block[0];
    temp[5] = block[1];
    temp[6] = block[2];
    temp[7] = block[3];

    for (int i = 0; i < 8; i++) {
        block[i] = temp[i];
    }
}

void RoundFunction(uint8_t block[8], uint8_t subKey[8]) {
    // Split the block into left and right sides
    uint8_t left[4];
    uint8_t right[4];
    uint8_t temp[4];
    for (int i = 0; i < 4; i++) {
        left[i] = block[i];
        right[i] = block[i + 4];
    }

    // XOR the right side with the subkey
    temp[0] = right[0] ^ subKey[0];
    temp[1] = right[1] ^ subKey[1];
    temp[2] = right[2] ^ subKey[2];
    temp[3] = right[3] ^ subKey[3];

    // Sbox the temp value
    Sbox(temp);

    // XOR the left side with the right side
    left[0] = left[0] ^ temp[0];
    left[1] = left[1] ^ temp[1];
    left[2] = left[2] ^ temp[2];
    left[3] = left[3] ^ temp[3];

    // Combine the left and right sides, swapping the left and the right
    for (int i = 0; i < 4; i++) {
        block[i] = right[i];
        block[i + 4] = left[i];
    }

    printf(" Block: ");
    for (int i = 0; i < 8; i++) {
        printf("%02X ", block[i]);
    }
    printf(" Subkey: ");
    for (int i = 0; i < 8; i++) {
        printf("%02X ", subKey[i]);
    }
    printf("\n");
}

void InitialPermutation(uint8_t block[8]) {
    uint8_t permutationTable[] = {2, 5, 1, 7, 4, 0, 6, 3};
    uint8_t tempBlock[8];

    for (int i = 0; i < 8; i++) {
        tempBlock[i] = block[permutationTable[i]];
    }

    for (int i = 0; i < 8; i++) {
        block[i] = tempBlock[i];
    }
}

void FinalPermutation(uint8_t block[8]) {
    uint8_t inversePermutationTable[] = {5, 2, 0, 7, 4, 1, 6, 3};
    uint8_t tempBlock[8];

    for (int i = 0; i < 8; i++) {
        tempBlock[i] = block[inversePermutationTable[i]];
    }

    for (int i = 0; i < 8; i++) {
        block[i] = tempBlock[i];
    }
}

void Sbox(uint8_t x[4]) {
}

void Encrypt(uint8_t block[8], uint8_t key[16]) {
    uint8_t subKeys[16][8];
    SubKeyGeneration(key, subKeys);
    InitialPermutation(block);
    for (int i = 0; i < 16; i++) {
        RoundFunction(block, subKeys[i]);
    }
    CrissCross(block);
    FinalPermutation(block);
}

void Decrypt(uint8_t block[8], uint8_t key[16]) {
    uint8_t subKeys[16][8];
    SubKeyGeneration(key, subKeys);
    InitialPermutation(block);
    for (int i = 15; i >= 0; i--) {
        RoundFunction(block, subKeys[i]);
    }
    CrissCross(block);
    FinalPermutation(block);
}

int main() {
    uint8_t key[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    uint8_t block[8] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};


    printf("Plaintext: ");
    for (int i = 0; i < 8; i++) {
        printf("%02X ", block[i]);
    }
    printf("\n\n");

    Encrypt(block, key);
    printf("\nEncrypted Block: ");
    for (int i = 0; i < 8; i++) {
        printf("%02X ", block[i]);
    }
    printf("\n\n");

    Decrypt(block, key);
    printf("\nDecrypted Block: ");
    for (int i = 0; i < 8; i++) {
        printf("%02X ", block[i]);
    }
    printf("\n\n");

    return 0;
}
